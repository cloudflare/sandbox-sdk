name: Cleanup Stale PR Resources

permissions:
  contents: read
  pull-requests: read
  actions: write # Required for gh cache delete

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  cleanup-stale:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Cleanup stale PR resources
        run: |
          echo "=== Checking for stale PR resources ==="

          # Get current timestamp (in seconds)
          CURRENT_TIME=$(date +%s)
          STALE_THRESHOLD=$((24 * 60 * 60)) # 24 hours in seconds

          # List all workers and filter for PR test workers
          WORKERS=$(npx wrangler workers list --json 2>/dev/null || echo "[]")

          echo "$WORKERS" | jq -r '.[] | select(.name | test("^sandbox-e2e-test-worker-pr-[0-9]+(-http|-websocket)?$")) | .name' | while read -r WORKER_NAME; do
            if [ -z "$WORKER_NAME" ]; then
              continue
            fi

            # Extract PR number from worker name (strip prefix and any transport suffix)
            PR_NUMBER=$(echo "$WORKER_NAME" | sed 's/sandbox-e2e-test-worker-pr-//' | sed 's/-http$//' | sed 's/-websocket$//')

            echo ""
            echo "Checking worker: $WORKER_NAME (PR #$PR_NUMBER)"

            # Check if PR exists and get its last update time
            PR_INFO=$(gh pr view "$PR_NUMBER" --json state,updatedAt 2>/dev/null || echo "")

            if [ -z "$PR_INFO" ]; then
              echo "  ⚠️  PR #$PR_NUMBER not found - will clean up"
              SHOULD_CLEANUP=true
            else
              PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
              PR_UPDATED=$(echo "$PR_INFO" | jq -r '.updatedAt')
              PR_UPDATED_SECONDS=$(date -d "$PR_UPDATED" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%SZ" "$PR_UPDATED" +%s 2>/dev/null)

              TIME_SINCE_UPDATE=$((CURRENT_TIME - PR_UPDATED_SECONDS))
              HOURS_SINCE_UPDATE=$((TIME_SINCE_UPDATE / 3600))

              echo "  State: $PR_STATE"
              echo "  Last updated: $HOURS_SINCE_UPDATE hours ago"

              if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ]; then
                echo "  ✓ PR is closed/merged - will clean up"
                SHOULD_CLEANUP=true
              elif [ "$TIME_SINCE_UPDATE" -gt "$STALE_THRESHOLD" ]; then
                echo "  ✓ PR is stale (>24h inactive) - will clean up"
                SHOULD_CLEANUP=true
              else
                echo "  ✗ PR is active - skipping"
                SHOULD_CLEANUP=false
              fi
            fi

            # Cleanup if needed
            if [ "$SHOULD_CLEANUP" = true ]; then
              echo "  Calling cleanup script for: $WORKER_NAME"
              # Call cleanup script (indent output for readability)
              ../../../scripts/cleanup-test-deployment.sh "$WORKER_NAME" 2>&1 | sed 's/^/  /'
            fi
          done

          echo ""
          echo "=== Stale worker cleanup complete ==="
        working-directory: tests/e2e/test-worker
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup stale registry images
        run: |
          echo "=== Checking for stale registry images ==="

          # List all images and find PR-tagged ones
          IMAGES=$(npx wrangler containers images list 2>/dev/null || echo "")

          # Extract unique PR numbers from image tags
          PR_NUMBERS=$(echo "$IMAGES" | grep -oE 'pr-[0-9]+' | sed 's/pr-//' | sort -u)

          for PR_NUMBER in $PR_NUMBERS; do
            if [ -z "$PR_NUMBER" ]; then
              continue
            fi

            echo ""
            echo "Checking images for PR #$PR_NUMBER..."

            # Check if PR is closed/merged
            PR_STATE=$(gh pr view "$PR_NUMBER" --json state -q '.state' 2>/dev/null || echo "NOT_FOUND")

            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ] || [ "$PR_STATE" = "NOT_FOUND" ]; then
              echo "  PR is $PR_STATE - cleaning up images..."

              for image in sandbox sandbox-python sandbox-opencode sandbox-standalone; do
                echo "  Deleting $image:pr-$PR_NUMBER..."
                npx wrangler containers images delete "$image:pr-$PR_NUMBER" 2>/dev/null || true
              done
            else
              echo "  PR is $PR_STATE - skipping"
            fi
          done

          echo ""
          echo "=== Stale image cleanup complete ==="
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup stale GHA caches
        run: |
          echo "=== Checking for stale GHA caches ==="

          # List all caches and find PR branch ones
          CACHES=$(gh cache list --json ref -q '.[].ref' 2>/dev/null || echo "")

          # Filter for PR merge refs
          echo "$CACHES" | grep -E 'refs/pull/[0-9]+/merge' | while read -r REF; do
            if [ -z "$REF" ]; then
              continue
            fi

            PR_NUMBER=$(echo "$REF" | grep -oE '[0-9]+')

            echo ""
            echo "Checking cache for PR #$PR_NUMBER..."

            # Check if PR is closed/merged
            PR_STATE=$(gh pr view "$PR_NUMBER" --json state -q '.state' 2>/dev/null || echo "NOT_FOUND")

            if [ "$PR_STATE" = "CLOSED" ] || [ "$PR_STATE" = "MERGED" ] || [ "$PR_STATE" = "NOT_FOUND" ]; then
              echo "  PR is $PR_STATE - cleaning up cache..."
              gh cache delete --all --ref "$REF" || true
            else
              echo "  PR is $PR_STATE - skipping"
            fi
          done

          echo ""
          echo "=== Stale cache cleanup complete ==="
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
